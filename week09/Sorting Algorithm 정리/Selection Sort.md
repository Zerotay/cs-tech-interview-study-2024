# Selection Sort

- 해당 순서에 원소를 넣을 위치는 이미 정해져 있고, 어떤 원소를 넣을지 선택하는 알고리즘. 
- 현재 위치에 들어갈 데이터를 찾아 선택하는 알고리즘. 
- 비교 정렬
- 제자리 정렬
- 불안정 정렬

### 💡 정렬 과정
1. 주어진 리스트에서 최솟값을 찾는다. 
2. 최솟값을 맨 앞자리의 값과 교환한다. 
3. 맨 앞자리를 제외한 나머지 값들 중 최솟값을 찾아 위와 같은 방법으로 반복한다. 

![img](https://github.com/GimunLee/tech-refrigerator/raw/master/Algorithm/resources/selection-sort-001.gif)

```java
package sortingAlgorithm;

public class SelectionSort {
    static int[] arr = new int[10];

    public static void main(String[] args) {
        arr = new int[]{4, 3, 6, 5, 7, 8, 12, 2, 1,10};
        selectionSort(arr);
        for (int i = 0; i < arr.length; i++) {
            System.out.print(arr[i] + " ");
        }
    }

    private static void selectionSort(int[] arr) {
        for (int i = 0; i < arr.length - 1; i++) {
            int min_idx = i;

            // 최솟값 찾기
            for (int j = i+1; j < arr.length; j++) {
                // min_idx 값보다 현재 값이 더 작으면 min_idx 갱신
                if (arr[min_idx] > arr[j]) {
                    min_idx = j;
                }
            }

            // 위에서 찾은 최솟값이랑 현재 값이랑 위치 swap
            swap(arr, min_idx, i);
        }
    }

    private static void swap(int[] arr, int i, int j) {
        int tmp = arr[i];
        arr[i] = arr[j];
        arr[j] = tmp;
    }
}

```

### 💡 시간복잡도
> 데이터의 개수가 n개라고 했을 때,
>
> - 첫 번째 회전에서의 비교횟수 : 1 ~ (n-1) => n-1
> - 두 번째 회전에서의 비교횟수 : 2 ~ (n-1) => n-2
> - `(n-1) + (n-2) + .... + 2 + 1 => n(n-1)/2`
>
>   비교하는 것이 상수 시간에 이루어진다는 가정 아래, n개의 주어진 배열을 정렬하는데 O(n^2) 만큼의 시간이 걸린다. 최선, 평균, 최악의 경우 시간복잡도는 **O(n^2)** 으로 동일하다.

### 💡 장단점
#### ✔ 장점
1. 알고리즘이 단순하다. 
2. 정렬하고자 하는 배열 안에서 교환하는 방식이므로, 다른 메모리 공간을 필요로 하지 않는다. (제자리 정렬)
#### ✔ 단점
1. 시간복잡도가 `O(n^2)` 으로, 비효율적이다.
2. 불안정 정렬이다. 

#### 📌 불안정 정렬
> 우리는 다음과 같은 배열을 정렬하고자 한다.
>
> **[B1, B2, C, A]     (A < B < C)**
>
> 주의해서 볼 점은 B에 붙어있는 숫자는 임의로 붙인 숫자다. B1이 B2보다 크거나 작은 것이 아니라는 점 유의하길 바란다.
>
> 그럼 순서대로 순회하면서 교환한다면 이렇다.
>
> round 1 : [**A**, B2, C, **B1**]
> round 2 : [A, **B2**, C, B1]
> round 3 : [A, B2, **B1**, **C**]
>
> 이렇게 초기의 B1 B2의 순서가 뒤 바뀐 것을 볼 수 있다.
>
> 이러한 상태를 불안정 정렬이라고 하는데 문제가 되는 이유는 예로들어 학생을 관리하고자 할 때, 성적순으로 나열하되, 성적이 같으면 이름을 기준으로 정렬하고 싶다고 할 때. 즉, 정렬 규칙이 다수이거나 특정 순서를 유지해야 할 때 문제가 될 수 있다.
>
> **[(가영, 60), (가희, 60), (찬호, 70), (동우, 45)]** 이렇게 리스트가 존재한다고 생각해보자. 성적순이되, 성적이 같다면 이름순으로 정렬해야 한다고 했다.
>
> 그러면 보통 이름을 일단 정렬을 해놓을 것이다.
>
> <이름 정렬 순>
> [(가영, 60), (가희, 60), (동우, 45), (찬호, 70)]
>
> 그 다음에 '성적 순'으로 정렬 할 것이다. 만약 선택 정렬을 하면 어떻게 되는지 보자.
>
> round 1 : [**(동우, 45)**, (가희, 60), **(가영, 60)**, (찬호, 70)]
> round 2: [(동우, 45), **(가희, 60)**, (가영, 60), (찬호, 70)]
> round 3: [(동우, 45), (가희, 60), **(가영, 60)**, (찬호, 70)]
>
> 이렇게 '가희'보다 '가영'이 앞에 있어야 함에도 순서가 바뀌어 버린 것을 볼 수 있다.