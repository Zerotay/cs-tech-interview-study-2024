# 메세징 플랫폼(메세지 큐)

RabbitMQ, Redis, Kafka와 같은 기술들을 메세징 플랫폼이라고 한다. 이러한 것들을 메세지 큐 모델이라고도 하며 **Queue**라는 자료구조를 채택해서 메세지를 전달하는 시스템이며, **메세지 지향 미들웨어(MOM)**을 구현한 시스템

### 메세지 지향 미들웨어(MOM)

메세지 지향 미들웨어란 응용 소프트웨어 간의 비동기적 데이터 통신을 위한 소프트웨어로 비동기적으로 프로세스간 데이터를 주고 받는 기능을 위한 시스템이다.

- 장점
    - 메세지의 백업 기능을 유지함으로써 지속성을 제공하며 이 덕분에 송수신 측은 동시에 네트워크 연결을 유지할 필요가 없음(보관)
    - 미들웨어 계층 자신이 직접 메세지 라우팅을 수행하기 때문에, 하나의 메세지를 여러 수신자에게 배포가 가능(라우팅)
    - 송수신 측의 요구에 따라 전달하는 메세지의 변환 가능(변환)

### 메세지 큐

메세지를 발행하고 전달하는 부분을 Producer 라고 하며, 메세지를 받아서 소비하는 부분을 Consumer. 여기에서 메세지 큐는 Producer 와 Consumer 의 메세지 전달 역할을 하는 매개체. 최근의 MSA환경에서 아키텍처의 핵심적인 역할을 수행

- **메세지 브로커 VS 이벤트 브로커**
    - 메세지 브로커
        - 메세지 브로커는 Producer 가 생산한 메세지를 메세지 큐에 저장하고, 저장된 메세지를 Consumer가 가져갈 수 있도록 한다.
        - 메세지 브로커는 Consumer 가 메세지 큐에서 데이터를 가져가게 되면 즉시 또는 짧은 시간 내에 메세지 큐에서 삭제시킨다.
        - 대규모 메세지 기반 미들웨어 아키텍쳐에서 사용
            - 미들웨어: 서비스하는 애플리케이션들을 위해 보다 효율적으로 아키텍쳐들을 연결하는 요소들로 작동하는 소프트웨어( ex)데이터 베이스 )
            - 즉, 메세지를 통신하고 네트워크를 맺는 용도로 사용
        - EX) RabbitMQ, Redis
        - 우리가 일반적으로 Redis를 메모리 기반의 NoSQL DB로 많이 알고 있지만 메세지 브로커로도 활용할 수 있다.(대표적으로 동시성 제어를 할때 Redis로 분산락을 사용할 때)
        - **RabbitMQ**
            - 우선순위 큐를 지원하여 우선 순위에 따라서 처리가 가능
            - 메세지가 성공적으로 전달되었다라고 판단될 경우 큐에서 삭제
            - 오래전에 개발되어 제품 성숙도와 안정성이 크다.
        - **Redis**
            - 채널에 메세지가 도착했을때, 해당 채널의 subcriber가 존재하지 않으면 메세지 삭제
            - 위와 같은 요소로 인해, 메세지의 도착을 보장하지 못한다.
            - 미들웨어가 필요없어서 가볍다.
    - 이벤트 브로커
        - 이벤트 또는 메시지라고 불리는 정보를 하나만 보관하고 인덱스를 통해 개별 엑세스를 관리
            - 업무상 필요한 시간 동안 이벤트를 관리
            - 메시지 브로커와 다르게 **이벤트가 삭제되지 않는다는 특징** 존재
            - 서비스에세 발생하는 이벤트를 데이터베이스에 저장하듯이 이벤트 브로커의 큐에 저장
        - 이벤트를 저장함으로써 얻는 장점
            - 딱 한번 일어난 이벤트 데이터를 브로커에 저장함으로써 모든 데이터 요소를 한 곳에서만 제어 또는 편집하도록 조작하는 관례에 맞게 동작(단일 진실 공급원)
            - 장애가 발생했을 때 장애가 일어난 지점부터 재처리 가능
            - 많은 양의 실시간 스트림 데이터를 효과적으로 처리 가능
        - 이벤트를 받아서 처리하면서 이벤트를 삭제하지 않음
        - 손실되면 안되는 요청을 처리할 때 좋음
        - 데이터가 소비되더라도 삭제되지 않는다
        - 기본적으로 이벤트 브로커는 메세지 브로커의 역할을 할 수 있지만, 메세지 브로커는 즉시 데이터 삭제된다는 특징 때문에 이벤트 브로커로의 역할을 수행할 수 없다.
        - EX) Kafka
- 장점
    - **비동기성**: Queue에 넣어두기 때문에 나중에 필요할 때 메세지를 처리할 수 있다. Queue라는 자료구조로 인하여 순서를 보장할 수 있다.
    - **낮은 결합도**: 애플리케이션과 분리하고, 애플리케이션끼리의 결합도를 낮출 수 있습니다. 이는 곧 MSA의 핵심 특징
    - **탄력성**: 시스템이 예기치 않은 상황 또는 장애에 대응하고 유연하게 대처할 수 있는 능력을 의미하는 것으로 위의 특징인 낮은 결합도로 인해 Producer나 Consumer 중 하나의 시스템이 장애가 발생하더라도 메세지를 발행하거나 소비하는 행위는 정상적으로 수행될 수 있다.
    - **과잉**: 작업을 메세지로 메세지 큐에 넣어두면 일정 장애 기간동안 송신된 메세지는 큐에 남아있어 추후 장애 복구 시 정상적으로 재시도 및 복구 가능
    - **신뢰성**: 송신된 메세지를 안전하고 확실하게 Consumer가 수신할 수 있다.
    - **확장성**: 메시지 큐를 이용한 통신에서 부하가 증가하더라도 메세지 큐에 Producer 와 Consumer를 추가함으로써 비교적 간단하고 쉽게 수평적 확장이 가능하다.
    

### 이벤트 브로커(Kafka)에서 메시지가 삭제되지 않는 이유

1. **로그 구조**: Kafka는 메시지를 파티션에 저장하는데 이를 로그에 추가하는 방식으로 저장. 각 메시지는 고유한 오프셋을 가지고 있으며, 특정 오프셋이나 설정된 byte가 넘어가면 새로운 segment가 생성되어 메시지가 관리된다. 소비자 그룹은 자신의 오프셋을 관리하여 메시지를 읽음.
2. **메시지 보존 정책**: Kafka는 보존 정책에 따라 메시지를 유지. 메시지는 일정 기간 동안 혹은 저장소 크기에 따라 보존.
3. **독립적 소비**: 각 소비자 그룹은 자신만의 오프셋을 가지고 있으므로, 하나의 소비자가 메시지를 읽어도 다른 소비자에게는 영향을 미치지 않는다. 이는 메시지가 여러 번 소비될 수 있음을 의미. (파티션이 분리되어 있기 때문)

### 참고

[https://velog.io/@choidongkuen/서버-메세지-큐Message-Queue-을-알아보자](https://velog.io/@choidongkuen/%EC%84%9C%EB%B2%84-%EB%A9%94%EC%84%B8%EC%A7%80-%ED%81%90Message-Queue-%EC%9D%84-%EC%95%8C%EC%95%84%EB%B3%B4%EC%9E%90)

[https://velog.io/@hwaya2828/메시지-플랫폼](https://velog.io/@hwaya2828/%EB%A9%94%EC%8B%9C%EC%A7%80-%ED%94%8C%EB%9E%AB%ED%8F%BC)
