# Context Switching

- **컨텍스트 스위칭에 대해 설명해주세요.**

  > - 하나의 CPU는 한 번에 하나의 스레드만을 실행시킬 수 있습니다. 이 때, 현대 CPU의 경우 빠르게 여러 개의 프로세스를 번갈아 실행하는 방식으로 동시성을 제공합니다. Context Switching이란 운영체제에서 작업하는 프로세스 또는 스레드 간의 전환되는 것을 의미합니다. I/O작업을 위한 인터럽트가 발생하거나 프로세스에 할당된 time slice가 만료된 경우 등의 상황에 Context Switching이 일어납니다. 
  > - Context Switching은 다음과 같은 순서로 일어납니다.
  > - 먼저, 현재 실행중인 프로세스에 대한 상태를 PCB에 저장합니다. 이후 Ready Queue에서 다음 실행할 프로세스를 결정하고 해당 프로세스의 PCB로부터 레지스터 값과 프로그램 카운터 등의 실행 상태를 복원합니다. 이후 메모리 공간이 변경된 경우, 프로세스 메모리 영역을 변경한 후 다음 프로세스를 진행합니다. 

- **프로세스 컨텍스트 스위칭과 스레드 컨텍스트 스위칭의 차이점은 무엇인가요 ?**

  > 프로세스의 컨텍스트 스위칭과 스레드의 컨텍스트 스위칭의 가장 큰 차이점은 **프로세스 컨텍스트 스위칭의 경우 가상 메모리 주소 관련 처리를 추가적으로 수행**한다는 점입니다. 가상 메모리 주소를 실제 메모리 주소로 변환해주는 MMU (Memory Management Unit)가 새로운 프로세스의 메모리 주소를 바라볼 수 있도록 해야하고, 실제 메모리 주소의 캐시 역할을 진행하는 TLB도 비워줘야 합니다. 

- **PCB에 대해 설명해주세요.**

  > PCB(Process Control Block)은 운영 체제에서 프로세스들의 정보를 관리하기 위해 사용되는 자료구조 입니다. 각각의 프로세스가 시작될 때 PCB가 생성되며 실행되는 동안 PCB를 사용하여 해당 프로세스를 추적 및 제어하고 프로세스가 종료될 때 해당 프로세스의 PCB는 사라집니다. PCB는 고유 식별자, 현재 실행 위치, 레지스터 값, 할당된 자원 등 프로세스의 상태정보를 저장하며 이를 활용해 프로세스 관리 및 Context Switching이 이루어 집니다. 

- **단기, 중기, 장기 스케줄러에 대해 설명해주세요.**

  >  컴퓨터에는 단기, 중기, 장기 스케줄러 있습니다. **장기 스케줄러**의 경우 프로세스 실행시에 해당 프로세스를 메모리 위 적재하여 Ready Queue에 넣을지 말지를 결정하는 역할을 수행합니다. **중기 스케줄러**의 경우 메모리에 올라와 있는 프로세스 중 Swap out 할 프로세스를 결정합니다. 마지막으로 **단기 스케줄러**의 경우 Ready Queue에 있는 프로세스들 중 CPU를 할당 할 프로세스를 결정하기 위해 사용됩니다. 

- **현대 OS 에서 사용되는 스케줄러 방식에 대해 설명해주세요.**

  >  현대의 시분할 시스템에서 생성된 프로세스는 모두 Ready Queue에 추가되며 장기 스케줄러는 사용하지 않는 것이 일반적입니다. 

- **OOM(Out Of Memory)가 발생한 경우 Process는 어떠한 상태로 변화하나요 ?**

  >메모리 부족으로 인해 필요한 자원이 사용 불가능해지면 프로세스는 대기상태(Waiting)로 전환될 수 있습니다. 이 때, CPU 자원을 모두 반환하고 다른 필요한 시스템 자원을 기다립니다.
  >
  >또한 메모리 부족으로 인해 Process가 중단되어야 하는 경우 OS는 해당 Process를 일시 중단(Suspend)할 수 있습니다. 이 상태에서는 메모리 내의 해당 프로세스의 모든 페이지가 제거되며 다시 실행하기 전 복원하여야 합니다. 

- **알고 있는 프로세스 스케줄링 알고리즘들을 말해주세요.**

  >  프로세스 스케줄링 알고리즘(단기 스케줄링 알고리즘)은 FIFO, SJF, 우선순위큐, RR 등이 있습니다. 
  >
  > **FCFS(First-Come-First-Served)**의 경우 먼저 Ready Queue에 들어온 프로세스부터 CPU에 할당하는 방법입니다. 이와 같은 경우 CPU 점유 시간이 짧은 프로세스가 이전 프로세스 때문에 오랜 시간 기다려야 하는 경우가 발생할 수 있습니다. (호위효과)
  >
  > **SJF(Short-Job-First)**의 경우 평균 대기 시간을 줄이기 위해 대기 하고 있는 프로세스 중 CPU 점유 시간이 짧은 프로세스(Short burst process)에 우선적으로 CPU를 할당하는 방식입니다. 해당 알고리즘은 계속해서 CPU 점유 시간이 짧은 프로세스가 들어오면 CPU 점유시간이 긴 프로세스의 경우 영원히 CPU를 할당받지 못하는 Starvation 현상이 발생할 수 있습니다.
  >
  > **우선순위 큐**와 같은 경우에는 프로세스마다 우선순위를 부여하고 프로세스의 우선순위에 따라 스케줄링을 수행합니다. 큐에서 가장 높은 우선순위를 가지는 프로세스가 실행되며, 동일한 우선순위를 가지는 프로세스끼리는 FCFS로 처리됩니다. 우선순위 큐는 선점형과 비선점형 두 가지로 구현될 수 있습니다. 해당 알고리즘 또한 낮은 우선순위의 프로세스가 영원히 CPU를 할당 받지 못하는 Starvation 현상이 발생할 수 있습니다. 
  >
  > **RR(Round-Robin)**은 시분할 방식으로 여러 프로세스 간에 CPU 시간을 공평하게 분할하여 실행하는 방식입니다. 각 프로세스는 동일한 Time Slice 동안 CPU를 할당받게 되고, Time Slice가 지나면 현재 실행 중인 프로세스는 중지된 후 Ready Queue로 돌아가고 다음 프로세스가 실행되는 방식으로 동작합니다. 

- **RR(Round Robin) 알고리즘에서 Time Slice에 따른 Trade-Off를 설명해주세요.**

  > RR에서 Time Slice가 길어지면 각 프로세스들 간의 실행되는 텀이 길어져 응답 시간이 느려져 결국 FCFS 와 같이 동작하게 되고, 만약 Time Slice가 짧다면 Context Switching이 더 빈번하게 일어나 오버헤드가 발생하게 됩니다. 

- **Multi-level Feedback Queue에 대해 설명해주세요.**

  > Multi-Level Feedback Queue는 여러 개의 우선순위 큐를 사용하여 프로세스를 관리하는 방식입니다. 각 Queue는 다른 우선 순위를 가지며, 서로 다른 스케줄링 알고리즘을 사용할 수 있습니다. 처음 프로세스가 Queue에 도착하면 가장 높은 우선순위 큐에 할당되고 프로세스가 큐에서 실행되는 동안 프로세스의 우선순위가 feedback에 따라 변경될 수 있습니다. 
  >
  > 예를 들어, 일정 시간 동안 device queue에서 I/O 작업을 대기하는 프로세스는 우선순위가 낮은 큐로 이동될 수 있습니다. 
  >
  > 해당 알고리즘의 특징으로는 각 level의 queue마다 개별적인 스케줄링 알고리즘을 적용할 수 있다는 것과 각 level 별로 time slice를 조절할 수 있다는 것입니다. 

---



### ✨ Process Management

- CPU가 프로세스가 여러개일 때, CPU 스케줄링을 통해 관리하는 것을 말함. 
- 이 때, CPU 는 각 프로세스들이 누군지 알아야 관리가 가능한데, 프로세스들의 특징을 갖고 있는 것이 바로 **Process Metadata** 이다. 



#### 💡 Process Metadata

- Process ID (PID) : 프로세스 고유 식별 변호 / Process Identification Number
- Process State  : 프로세스의 현재 상태(준비, 실행, 대기 등의 상태)를 저장
- Process Priority : 프로세스 우선순위 등과 같은 스케줄링 관련 정보를 저장
- CPU Registers : 프로세스의 레지스터 상태를 저장하는 공간
- Owner : CPU 사용시간의 정보(Quantum), 각종 스케줄러에 필요한 정보를 기억
- Program Counter : 다음에 실행되는 명령어의 주소를 기억 
- I/O Status Information : 프로세스 수행 시 필요한 주변 장치, 파일들의 정보를 기억 
- CPU Usage
- Memory Usage



- 위 메타데이터는 프로세스가 생성되면 **PCB(Process Control Blcok)** 에 저장됨.



#### 💡 PCB (Process Control Block)

- 프로세스의 메타데이터들을 저장해 놓는 곳. 
- 한 PCB 안에는 프로세스의 정보가 담긴다. 

<img src="https://t1.daumcdn.net/cfile/tistory/25673A5058F211C224" alt="img" style="zoom:50%;" />

> 프로그램 실행 -> 프로세스 생성 -> 프로세스 주소 공간에 코드, 데이터, 스택 생성 -> 이 프로세스의 메타데이터들이 PCB에 저장



- **PCB의 필요성**

  - 프로세스가 여러 개 생성될 때, CPU 는 프로세스의 상태에 따라 교체 작업을 수행

    > Interrupt 발생 -> 할당 받은 프로세스 Waiting 상태로 변경 -> 다른 프로세스를 Running 상태로 변경

  - 따라서, 수행 대기 중인 프로세스에 관한 저장 값을 PCB에 저장해 두어야 함. 

  - PCB는 LinkedList 방식으로 관리되어 삽입과 삭제가 용이함. 

  - 프로세스가 생성될 때 PCB List Head 에 PCB 가 삽입되고 프로세스가 완료되면 PCB가 삭제되는 식으로 관리가 됨. 

    > - PCB 가 Head 에 붙는 경우![img](https://t1.daumcdn.net/cfile/tistory/214B134158F2139309)

    

    > - PCB가 제거될 때  
    >
    > ![img](https://t1.daumcdn.net/cfile/tistory/2716704358F2141716)

  - 생성과 제거 시에 주소값을 넘겨 받아 연결이 이루어짐. 



#### 💡 Context Switching

- 수행중인 Task(Process/Thread)가 변경될 때, CPU의 레지스터 정보가 변경되는 것. 
- 이전 프로세스의 상태를 PCB에 보관하고, 다른 프로세스의 정보를 PCB에서 읽어와 CPU 레지스터에 적재하는 과정. 
- 보통 인터럽트 발생, 혹은 현재 프로세스의 타임 슬라이스가 만료되었을 경우, 입출력을 위해 대기하는 경우에 발생. 

- 프로세스가 `Ready -> Running` , `Running -> Ready`, `Running -> Waiting` 처럼 상태 변경 시 발생.

- **필요성**
  - 프로세스 수행 중 입출력 이벤트가 발생해서 해당 프로세스를 대기 상태로 전환시켰을 때 CPU 를 그냥 놔두는 것 보다 다른 프로세스를 수행시키는 것이 효율적이기 때문



> 1. 현재 실행중인 프로세스 혹은 스레드의 context 백업 (예를 들어, CPU 레지스터 값들, 어디까지 실행됐는지 등)
> 2. CPU 캐시를 비움 (flush) 
>    - CPU마다 L1, L2 cache 에 대한 동작이 다를 수 있음, 심지어 안 비울 수도 있음
> 3. TLB (Table Lookaside Buffer) 를 비움
> 4. MMU (Memory Management Unit) 을 비움

- 프로세스 컨텍스트 스위칭은 1~4번 모두 수행하지만 스레드 컨텍스트 스위칭은 1번만 수행.

---



## ✨ CPU Scheduling

### 💡 스케줄러(Scheduler) 란 ?

- 한정적인 메모리를 여러 프로세스가 효율적으로 사용할 수 있도록 다음 실행 시간에 실행할 수 있는 프로세스 중에 하나를 선택하는 역할



#### 1. 장기 스케줄러 (Long-term Scheduler) / 잡 스케줄러 (Job Scheduler)

- 현재 수행해야 할 job이 10개이고, 메모리에는 6개 밖에 올릴 수 없을 때 어떤 것을 올릴 지 결정하는 것이 **장기 스케줄러**.
- 풀로부터 프로세스들을 선별하고 실행을 위해 메모리에 적재. (Ready Queue 에 적재)
- 메모리와 디스크 사이의 스케줄링을 담당.
- 프로세스의 상태 `new -> ready (in memory)`

> #### 장기 스케줄러는 요즘에 없다 ?
>
> 요즘은 10개가 실행 준비가 되면 메모리로 10개가 다 올라간다. 그 이유는 이전에는 없었던 **virtual memory management**가 발달되었기 때문이다. 즉! 오늘날에는 long term scheduling 은 의미가 없다. long term 이 있어야 short term이 있는 것인데, long term 이 없어서 오늘날엔 그냥 CPU Scheduling 이라고 한다. 



#### 2. 단기 스케줄러 (Short-term Scheduler) / CPU 스케줄러 (CPU Scheduler)

- 장기 스케줄러에 의해 6개의 작업이 메모리에 있지만 실제 CPU가 수행하는 것은 하나. 
- 6대 중에서 결국 또 하나를 고르는 것을 담당하는 것이 **단기 스케줄러**.
- CPU 를 차지할 작업을 스케줄링해주는 것이기에 다른 말로 CPU Scheduler 라고 불림. 
- CPU와 메모리 사이의 스케줄링을 담당. 
- 프로세스의 상태 `ready -> running -> waiting -> ready`



#### 3. 중기 스케줄러 (Mid-term Scheduler) / 스와퍼 (Swapper)

- 장기, 단기 이후에 생겼으나 이것도 요즘 운영체제에는 없음. 
- 장기에서 선택된 6개를 수행하고 있지만 너무 많아 감당하기가 어려워 몇 개를 내보내려고 할 때, 무엇을 내보낼지 결정하는 것이 **중기 스케줄러**.
- 프로세스를 내릴 때 우선순위가 가장 낮은 프로세스나 일정 시간 동안 활성되지 않았던 프로세스를 내린다. 
- 프로세스를 내리고, 올리고 하는 것을 swapping 이라고 하기 때문에 **Swapper** 이라고 불린다. 
- 현 시스템에서 메모리에 너무 많은 프로그램이 동시에 올라가는 것을 조절하는 것을 담당.
- 프로세스 상태 `ready -> suspended`



#### ✔ 현대 OS에는 단기, 중기, 장기 스케줄러를 모두 사용하고 있나요 ?

> - 장기 스케줄러 : 사용하지 않는다. 
>   - 장기 스케줄러는 일괄처리 시스템에서 사용한다. (자원 독점)
>   - 현대 운영체제에서는 대부분 시분할 방식인 Round Robin 을 사용한다. (자원 독점 X)
>     - 시분할 방식에서 프로세스는 시작과 동시에 메모리를 할당해 Ready Queue에 넣는다. 
>   - 가상 메모리의 사용으로 잘 사용하지 않는다. 
> - 중기 스케줄러 : 잘 사용하지 않는다. 
>   - 가상 메모리를 사용하면 프로세스의 전체가 아닌 일부만 실제 메모리에 올라와도 된다. 
>   - 따라서 실제 메모리 용량보다 큰 프로그램을 실행시킬 수 있고 메모리의 크기에 제약이 없어졌다. 
> - 단기 스케줄러 : 여전히 사용한다. 



---



## ✨ 프로세스 스케줄링 알고리즘

### 💡 비선점형 스케줄링 (Nonpreemptive)

- 어떤 프로세스가 CPU를 점유하고 있다면 이를 뺏을 수 없는 방식.
- 강제로 프로세스를 중지하지 않는다. 
- 따라서 Context Switching 으로 인한 부하가 상대적으로 적지만 프로세스의 배치에 따라 효율성 차이가 많이 남. 



#### 1. FCFS (First Come, First Served)

![img](https://velog.velcdn.com/images/qq7455/post/e81e9f3c-a501-4472-b560-fda915061728/image.png)

- 가장 먼저 요청한 프로세스에 CPU를 할당해주는 선착순 방식.
- FCFS 의 경우 평균 대기 시간은 일반적으로 최소가 아님. 
- **Convoy Effect (호위 효과)** 
  - 몇 개의 시간이 오래 걸리는 프로세스로 인해 전체 OS가 느려지는 현상
  - 짧은 프로세스들이 먼저 처리되도록 허용될 때 이득



#### 2. SJF (Shortest Job First)

![img](https://velog.velcdn.com/images/qq7455/post/67d48488-e4ce-45f9-8ff0-9c8a5e7544e2/image.png)

- 실행 시간이 가장 짧은 프로세스를 먼저 실행하는 알고리즘. 
- 실제로는 프로세스의 CPU 실행 시간을 예측하는 것이 어려움.
- 긴 시간을 필요로 하는 프로세스의 우선순위가 계속 밀려 실행되지 못하고 무기한으로 대기하게 되는 **Starvation 현상**이 일어날 수 있음. 

> #### Shortest-Remaining-Time-First (SRTF)
>
> - 현재 수행중인 프로세스의 남은 Burst Time 보다 더 짧은 CPU Burst Time 을 가지는 새로운 프로세스가 도착하면 CPU 를 빼앗김.
> - SJF 는 일단 CPU를 잡으면 이번 CPU Burst 가 완료될 때 까지 CPU를 선점당하지 않음. 



#### 3. Priority Scheduling

- 각각의 프로세스에 우선순위가 있는 알고리즘. 
- SJF 의 경우 일종의 우선 순위 스케줄링. 
  - priority = predicted next CPU burst time
- 낮은 우선순위 프로세스들이 CPU 를 무한히 대기할 수 있는 Starvation 이 일어날 수 있음. 
- Aging 과 같은 방법으로 해결. 
  - 오랫동안 시스템에서 대기하는 프로세스들의 우선순위를 점진적으로 증가시킴. 



### 💡 선점형 스케줄링 (Preemptive)

- 현대 운영체제가 사용하고 있는 방식
- 어떤 프로세스가 CPU를 할당받아 실행중이더라도 운영체제가 이를 강제로 뻇을 수 있는 방식.
- 알고리즘에 따라 강제로 중단시키고 다른 프로세스에 CPU에 할당하는 방식.
- 처리 시간이 매우 긴 프로세스의 CPU 사용 독점을 막을 수 있어 효율적인 운영은 가능하지만 잦은 Context Switching 으로 인해 오버헤드가 커질 수 있음. 

#### 1. Round Robin (RR)

![img](https://velog.velcdn.com/images/qq7455/post/50356c89-c974-45cd-aae2-15c2b14f8ca3/image.png)

- 현대 컴퓨터가 사용하는 우선순위 스케줄링.
- 각각의 프로세스에 동일한 할당 시간을 부여해서 해당 시간 동안만 CPU를 이용하도록 함. 
- 할당 시간 내에 처리를 완료하지 못하면 강제 중단 후 다음 작업으로 넘어가므로 선점형.
- 할당 시간이 지나면 프로세스는 선점당하고, Ready Queue의 제일 뒤에 가서 다시 줄을 선다. 

- 응답 시간을 빠르게 할 수 있다는 장점이 있지만 **할당 시간이 길면 FCFS처럼** 작동하고, 반대로 **할당 시간이 너무 짧으면 process sharing** 이라고 부른다. 

  > n개의 프로세스가 Ready Queue에 있고 할당 시간(time quantum) 이 **q time unit**  인 경우 각 프로세스는 최대 q time unit 단위로 CPU 시간의 **1/n** 을 얻는다. 
  >
  > 어떤 프로세스도 (n-1)q time unit 이상 기다리지 않는다. 

  > **기본 베이스는 Ready Queue** 가 **FCFS** 로 동작하게 만듦. 
  >
  > 그 후 CPU 스케줄러는 Ready Queue 에서 첫 번째 프로세스를 선택해 한 번의 시간 할당량 이후에 인터럽트를 걸도록 타이머를 설정한 후, 프로세스를 디스패치 한다. 
  >
  > - **프로세스의 CPU 버스트가 한 번의 시간 할당량보다 작다면 ?** 
  >   - 프로세스 스스로 CPU를 방출하게 되고, 다음 프로세스로 이동. 

- 일반적으로 **시간 할당량이 Context Switching 시간과 비교해 더 크도록 설정**. 



#### 2. Multi-Level Queue

- Ready Queue 를 여러 개로 분할하고, 각 큐는 독립적인 스케줄링 알고리즘을 가짐. 
- 우선순위가 높은 큐부터 처리되기 때문에 낮은 큐의 프로세스가 처리가 안되는 Starvation 현상이 나타날 수 있음.
- 각 큐 사이에서 프로세스들이 이동할 수 없어 유연성이 떨어짐.



#### 3. Multi-Level Feedback Queue

- 위의 Multi-Level Queue 를 보완하여 각 단계의 큐에 Round Robin 방식을 사용하고 CPU 를 사용한 프로세스는 우선순위가 하나 낮은 큐의 끝으로 들어감. 
- 우선순위에 따라 타임 슬라이스의 크기가 다름. 

> MLFQ 는 각기 다른 Priority Level 이 부여된 각기 다른 몇 개의 Queue로 구성되는데, 실행될 준비가 된 작업은 이 큐들 중 하나에 반드시 속한다. 
>
> MLFQ 는 이 우선 순위를 실행할 작업을 선택하는데 사용하는데, 여러 개의 작업 중 높은 우선 순위를 가지는 작업, 즉 더 상위의 큐에 있는 작업이 스케줄러로부터 선택받아 실행됨.
>
> 우선 순위가 부여되는 것이 작업이 아닌 **큐**이므로, 같은 큐에 속해 있는 작업들은 같은 우선 순위를 가지기 때문에 이 때는 Round-Robin 방법으로 작업을 실행시켜줌. 

[Multi-Level Feedback Queue 아주 자세히 알아보기](https://velog.io/@qkrdbqls1001/OS-8.-Scheduling-The-Multi-Level-Feedback-Queue)



#### ✔ MLFQ 특징

- 여러 개의 큐를 가지고 있다. 
- 각 큐는 서로 다른 우선순위를 갖는다. 
- Ready 상태인 모든 프로세스들은 어떤 큐 안에 들어있다. 
- MLFQ는 각 작업에 고정된 우선순위를 부여하는 것이 아니라 각 작업의 **특성에 따라 동적으로 우선순위를 부여한다.**

#### ✔ MLFQ 규칙

1. 우선순위가 높은 프로세스들을 먼저 수행한다. 
2. 작업들이 같은 우선순위를 갖는다면 RR로 수행한다.
