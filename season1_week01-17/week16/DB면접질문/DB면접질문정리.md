# Database


#### 1. RDB & NoSQL
- **RDB와 NoSQL의 차이점에 대해서 설명해주세요.**
    > RDB와 NoSQL의 가장 큰 차이점은 Schema의 여부와 관계의 존재 여부입니다. RDB의 경우 정해진 스키마에 부합하는 데이터만을 저장할 수 있지만 NoSQL의 경우 스키마가 존재하지 않고 Documents나 Key-Value 등의 방식으로 저장합니다. 또한 RDB에서는 여러가지 Table에 대한 관계를 통해 데이터 간의 상관관계를 설정하지만 NoSQL의 경우에는 하나의 documents에 모든 데이터가 들어가 있기 때문에 관계를 사용하지 않습니다. 이런 특성 때문에 NoSQL은 입출력 속도가 빠르며 Scale Out에 적합합니다.
    
- **본인이 사용한 RDBMS 기준으로 쿼리 실행 과정을 설명해주세요.**
    > 클라이언트가 DBMS에 SQL문을 요청합니다. DB는 해당 요청을 받아 Parser를 이용해 해당 SQL문을 파싱합니다. 이 과정에서 SQL 문법의 유효성 검사를 진행하고 트리 형식으로 변환됩니다. 이후 전처리기를 이용하여 Parse Tree를 기반으로 SQL 문장 구조를 체크하고 토큰이 유효한지 체크합니다. 이후 옵티마이저가 Tree를 기반으로 최적 SQL 실행 계획을 수립합니다. 이후 실행 엔진이 실행 계획을 기반으로 스토리지 엔진을 호출해서 실제 데이터 변경을 수행합니다.
    >
    > [참고](https://www.youtube.com/watch?v=vQFGBZemJLQ)
    
- **스토리지 엔진이 무엇이며 실행 엔진과는 무슨 차이점이 있는지 말해주세요.**
    
    > 스토리지 엔진은 쿼리 실행 엔진이 요청하는 대로 데이터를 실제로 디스크에 저장하고 읽는 역할을 수행합니다. Handler API에 의해 동작하며 플러그인 형태로 제공되기 때문에 사용자는 원하는 스토리지 엔진을 사용할 수 있습니다. 실행엔진의 경우 주어진 실행 계획을 바탕으로 스토리지 엔진을 호출하는 역할을 수행합니다.
    
- **옵티마이저는 무엇인지 설명해주세요.**
    > 옵티마이저란 Parser Tree를 기반으로 최적 SQL 실행계획을 수립하는 모듈입니다. 옵티마이저는 다양한 실행 계획을 고려하고, 각 계획의 비용을 추정하여 가장 효율적인 실행 계획을 선택합니다. (다양한 실행 계획들을 비교하는데 있어 DBMS의 성능 통계정보를 사용합니다.) 이를 통해 데이터베이스 시스템의 성능과 효율성을 향상시키는 역할을 합니다.
    
- **NoSQL의 종류를 아는대로 말해주세요.**
    > MongoDB와 같이 documents를 기준으로 데이터를 저장하는 documents-based, redis와 같이 key-value 형태로 데이터를 저장하는 Key-Value DB, cassandra와 같이 각 행마다 다른 Column들을 가지는 column family-based 방식 등이 있습니다.
    
- **회사 서비스과 관련하여 각 DB들을 어떻게 사용할 수 있을 지 말해주세요.**
    > 실시간 데이터 처리와 빠른 데이터 조회가 필요한 기능에는 NoSQL을 사용하여 빠른 입출력 성능을 확보할 수 있습니다. 반면, 정규화된 데이터 구조와 데이터 무결성이 중요한 거래 기록이나 사용자 정보 관리 등에는 RDBMS를 사용하여 안정적인 트랜잭션 관리와 관계형 데이터를 활용할 수 있습니다. Redis와 같은 Key-Value 저장소는 세션 관리나 캐시와 같이 일시적으로 저장하고 빠르게 접근해야 하는 데이터에 유용하게 활용할 수 있습니다.


#### 2. Transaction
- **트랜잭션이 무엇이고 어떤 특징을 가지는지 말해주세요(ACID).**
    > 트랜잭션이란, 데이터베이스에 적용되는 변경사항들의 최소 단위로써 ACID 원칙을 따릅니다. A, 원자성이란, 하나의 트랜잭션 안의 변경 사항들은 모두 commit이 되거나 또는 모두 rollback이 되어야 함을 의미합니다. C, 일관성은 트랜잭션이 일어난 후에도 DB 스키마를 만족하여야함을 의미합니다. I, 고립성이란 동시에 수행되는 트랜잭션 간에 영향을 미치지 않아야 함을 의미합니다. 마지막으로 D, 영구성은 커밋된 트랜잭션이 영구적으로 보존되어 시스템 오류 등의 문제가 발생하더라도 복구될 수 있어야 함을 의미합니다.
    
- **ACID 중 데이터베이스에서 원자성을 보장하는 방식을 설명해주세요.**
    > 데이터베이스는 트랜잭션의 원자성을 보장하기 위해 트랜잭션이 완료되기 전까지 모든 변경 사항을 메모리에서 유지하며, 트랜잭션이 성공적으로 완료되면 모든 변경 사항을 커밋합니다. 반대로 트랜잭션에 오류가 발생하면 변경 사항을 취소하고 이전 상태로 되돌리는 롤백을 수행하여 트랜잭션이 중간 단계에서 중단되더라도 데이터가 손상되지 않도록 보장합니다.
    >
- **데이터베이스가 Durability를 보장하는 방식을 설명해주세요**
    > Durability는 성공적으로 커밋된 트랜잭션은 전원 차단, 시스템 오류 등의 문제가 발생하더라도 복구될 수 있어야 함을 의미합니다. DBMS는 일반적으로 logging을 통해 durability를 구현합니다. 트랜잭션이 커밋되면 이는 트랜잭션 로그에 저장되며, 해당 로그는 비휘발성인 디스크에 저장되게 됩니다. 시스템 오류가 발생한 경우 DBMS의 복구 메커니즘은 해당 트랜잭션 로그를 사용하여 마지막 트랜잭션이 커밋된 시점의 DB를 재구성합니다.
    
- **트랜잭션을 사용해본 경험이 있는지? 어떤 경우에 사용할 수 있나요?**
    > 트랜잭션은 금융 데이터 처리, 주문 시스템, 사용자 정보 업데이트 등 데이터의 일관성과 무결성이 중요한 작업에 사용됩니다. 예를 들어, 결제 시스템에서는 결제 성공 시 주문 정보와 재고 수량을 동시에 업데이트하는 트랜잭션을 사용하여, 중간 단계에서 오류가 발생해도 데이터 불일치가 발생하지 않도록 보장할 수 있습니다.
    >
- **readOnly 로직의 경우 트랜잭션을 걸지 않아도 될까요?**
    > 일반적으로 readOnly 로직에서는 트랜잭션을 사용하지 않아도 무방합니다. 트랜잭션은 주로 데이터 변경 시에 필요하며, 읽기 전용 작업에서는 데이터 변경이 없기 때문에 격리성을 보장할 필요가 없을 수 있습니다. 그러나 특정 상황에서는 읽기 작업이 진행 중인 다른 트랜잭션과의 일관성을 보장하기 위해 readOnly 트랜잭션을 사용할 수도 있습니다.
    >
- **분산 환경에서는 트랜잭션을 어떻게 관리할 수 있을까요?**
    > 분산 환경에서는 트랜잭션 관리를 위해 2PC (Two-Phase Commit)와 같은 분산 트랜잭션 프로토콜을 사용할 수 있습니다. 2PC는 트랜잭션의 각 노드에 변경 사항을 준비(prepare)시키고, 모든 노드가 준비 완료 응답을 보내면 커밋하는 방식으로 동작합니다.
    > 또한 SAGA 패턴을 사용할 수 있습니다. SAGA 패턴은 긴 트랜잭션을 여러 개의 작은 로컬 트랜잭션으로 나누어 순차적으로 처리합니다. 실패 시 보상 트랜잭션을 실행해 데이터 일관성을 유지하며, 최종 일관성을 보장하는 방식이라 성능 면에서 유리합니다.
    >

#### 3. 트랜잭션 격리 수준
- **트랜잭션 격리 수준에 대해 설명해주세요.**
  > 트랜잭션 격리 수준은 여러 트랜잭션이 동시에 처리될 때 서로의 영향을 최소화하여 데이터 일관성을 보장하는 레벨입니다. 대표적인 격리 수준으로는 Read Uncommitted, Read Committed, Repeatable Read, Serializable이 있으며, 이 중 Read Uncommitted는 가장 낮은 격리 수준으로 다른 트랜잭션의 미완료 변경 사항도 볼 수 있고, Serializable은 가장 높은 격리 수준으로 완벽한 고립성을 보장하지만 성능이 낮을 수 있습니다.
  >
- **트랜잭션 격리 수준에 따라 발생할 수 있는 문제점들을 말해주세요.**
  > Read Uncommitted에서는 Dirty Read가 발생할 수 있으며, Read Committed에서는 Non-Repeatable Read가 발생할 수 있습니다. Repeatable Read에서는 Phantom Read가 발생할 수 있고, Serializable 수준에서는 이러한 문제가 해결되지만 동시성 처리 성능이 저하될 수 있습니다.
  >
- **MySQL을 사용하고 있다면 MySQL 스토리지 엔진(InnoDB)를 기준으로 Undo 영역과 Redo 영역에 대해 설명해주세요**
  > InnoDB 스토리지 엔진에서는 트랜잭션 격리와 복구를 위해 Undo와 Redo 영역을 사용합니다. Undo 영역은 트랜잭션이 롤백될 때 변경 내용을 되돌리기 위해 사용하며, Redo 영역은 트랜잭션 커밋 이후 장애가 발생하더라도 데이터를 복구할 수 있도록 변경 내용을 기록하는 역할을 합니다. 이를 통해 InnoDB는 원자성, 일관성, 영구성을 보장합니다.

#### 4. 조인 (JOIN)
- **알고 있는 JOIN의 종류들을 말해주세요.**
    > 결과적인 측면에서는 INNER JOIN, OUTER JOIN, LEFT JOIN, RIGHT JOIN, NATURAL JOIN 등이 있으며, JOIN의 동작 방식 적인 측면에서는 NL 조인, Sort Merge 조인, 해시 조인 등이 있습니다.
    
- **JOIN은 내부적으로 다양한 구현 방식을 사용하고 있습니다. JOIN의 원리에 대해 아는대로 말해주세요.**
    > JOIN의 구현 방식은 NL 조인, Sort Merge 조인, 해시 조인 등이 있습니다.
    >
    > 먼저 NL 조인(Nested Loop JOIN)의 경우 하나의 driving table을 순회하면서 다른 테이블(driven table)에서 JOIN 조건을 만족하는 레코드들을 찾아 JOIN을 수행하는 방식입니다. 이 방식의 경우에는 driven table에 인덱스 설정 여부가 성능에 큰 영향을 미치기 때문에 주로 driven table에 인덱스가 설정되어 있을 때 사용합니다.
    >
    > Sort Merge JOIN과 같은 경우에는 두 Table을 조건 칼럼에 대해 정렬작업을 수행한 후 조인하는 방식을 진행합니다. 이는 보통 Driven Table에 적절한 인덱스가 존재하지 않아 NL JOIN이 비효율 적이거나, Equal Join이 아닌
    >
    > [참고](https://velog.io/@jayl2sw/Database-%EC%A1%B0%EC%9D%B8Join%EC%9D%98-%EC%88%98%ED%96%89-%EC%9B%90%EB%A6%AC)
    
- **JOIN의 성능과 Index 사이에 어떤 관계가 있는지 말해주세요.**
    > NL JOIN의 경우 driven table에 index가 없다면 해당 테이블을 풀스캔 해야하기 때문에 Index가 있는 것이 driven table을 조회하는데 성능이 훨씬 좋습니다.
    
- **어떤 JOIN 방식을 사용하는지 어떻게 알 수 있나요?**
    > Database에서 EXPLAIN을 이용해 실행계획을 확인하면 해당 실행계획의 JOIN 방식을 알 수 있습니다. MySQL의 경우 NL만 지원합니다.
    

#### 5. 인덱스 (Index)
- **인덱스가 무엇인지 설명해주세요.**
    > 인덱스란 DB에서 데이터의 검색 및 조회를 빠르게 하기 위해 사용되는 자료구조입니다. 인덱스는 테이블의 하나 이상의 컬럼에 대한 값과, 해당 값이 저장된 행의 위치를 매핑하는 역할을 합니다. Index는 DB 성능을 향상시키고 검색 속도를 높이는데 중요한 역할을 합니다.
    
    - Index는 데이터베이스에서 table의 검색 성능을 높여주는 대표적인 방법 중 하나입니다. 일반적인 RDBMS에서는 B+Tree구조로 된 index를 사용하여 검색속도를 향상시킵니다. index는 책마다 마지막 페이지에 있는 색인과 같은 역할을 하는 자료구조입니다. 책에서 어떤 용어나 단어를 찾기 위해 첫 페이지부터 끝 페이지까지 훑지 않아도 index를 찾아보면 몇 페이지에 적혀 있는지 바로 찾을 수 있는 것과 비슷합니다.
    - `SELECT ~ WHERE` query를 통해 특정 조건을 만족하는 데이터를 찾을 때, full table scan을 할 필요 없이 정렬되어 있는 index에서 훨씬 빠른 속도로 검색을 할 수 있게 됩니다. 
    
- **인덱스는 어떤 구조로 구현될 수 있나요?**
    > 인덱스는 B tree 구조나 해시 테이블을 이용해서 구현될 수 있습니다. B 트리는 균형 이진 트리의 변형으로서, 트리의 높이를 최소화하여 검색 속도를 향상시키는 특징을 가지고 있습니다. 각 노드는 값들과 하위 노드를 가리키는 포인터를 가지고 있으며 값에 대한 대소비교를 통해 적합한 하위 노드를 탐색합니다.
    
- **B-tree와 B+ tree의 차이점과 각각의 장단점에 대해 설명해주세요.**
    > B tree의 경우 각 노드는 값과 포인터를 가지고 있습니다. B+ tree의 경우 각 노드는 하위 노드의 포인터만을 가지고 있으며 모든 값들은 리프노드에 있습니다. 또한, 모든 리프 노드들은 Linked List 형태로 연결되어 있어 구간 탐색에 용이하며, 모든 데이터 조회 시에도 한번의 선형 탐색으로 조회할 수 있습니다.
    >
    > [참고](https://velog.io/@jayl2sw/index)
    
- **Hash Table을 이용한 Index의 한계점은 무엇인가요?**
    > hash table을 이용한 index의 경우 부등호 연산(<>)이 포함되어 있을 경우 모든 데이터를 순회해야 하기 때문에 비효율적입니다.
    
- **ORDER BY/GROUP BY 연산의 동작 과정을 인덱스의 존재여부와 연관지어서 설명해 주세요.**
    > `ORDER BY`나 `GROUP BY` 연산은 정렬이나 그룹화가 필요한 연산으로, 인덱스가 있을 경우 큰 성능 향상을 기대할 수 있습니다. 예를 들어 `ORDER BY`에 사용되는 컬럼에 인덱스가 설정되어 있으면, 데이터가 이미 정렬된 상태로 저장되어 있으므로 추가적인 정렬 연산 없이 빠르게 결과를 반환할 수 있습니다. 마찬가지로, `GROUP BY`에서도 인덱스가 있으면 원하는 그룹별 데이터 집계가 더 빠르게 처리됩니다. 반면, 인덱스가 없는 경우 DB는 모든 데이터를 스캔하며 정렬이나 그룹화를 수행해야 하기 때문에 성능이 떨어질 수 있습니다.
    >
- **인덱스를 생성하는 기준을 대략적으로 설명해주세요.**
    > 인덱스는 주로 검색과 정렬이 빈번하게 발생하는 컬럼에 생성하는 것이 좋습니다. 자주 사용하는 `WHERE`, `ORDER BY`, `GROUP BY`에 포함되는 컬럼이나, JOIN 시 연결되는 컬럼에 인덱스를 설정하면 성능을 향상시킬 수 있습니다. 다만, 인덱스는 저장 공간을 추가로 소모하고, 데이터 삽입 및 수정 시 성능에 영향을 줄 수 있기 때문에, 조회 빈도가 높은 컬럼에만 필요에 따라 신중하게 생성하는 것이 좋습니다.
    >
- **where 절에서 like "A%"와 "%A%"의 동작방식에서의 차이를 말해주세요.**
    > A%의 경우 해당 컬럼에 Index가 존재한다면 해당 인덱스를 사용하여 조회할 수 있지만, "%A%의 경우 Index를 탈 수 없습니다. 따라서 일반적으로 관리자 모드 등에서는 "%A%"는 사용하지 않습니다.
    

#### 6. 정규화
- **정규화는 무엇이고 왜 하는 것인지 말해주세요.**
    > **정규화**란 관계형 데이터베이스의 설계에서 중복을 최소화하게 데이터를 구조화하는 프로세스를 의미합니다. 정규화를 통해 데이터를 여러 테이블에 나누어 저장함으로써, 데이터 변경 시 발생할 수 있는 이상 현상을 줄이고 유지 보수성을 높일 수 있습니다. 이를 통해 데이터 무결성을 확보하고 스토리지 효율성을 높이며, 데이터의 중복을 줄여 관리의 복잡성을 낮출 수 있습니다.
    
- **3차 정규화에 대해서 설명해주세요.**
    > 3차 정규화는 1차, 2차 정규화를 만족하며 즉, 모든 도메인이 원자값이고, 모든 종속자들이 결정자에 완전 함수적 종속하며, 이행적 함수적 종속이 없는 상태를 의미합니다. 이는 A -> B B -> C와 같이 어떠한 종속자도 결정자가 되지 않음을 뜻합니다.
    
- **정규화를 진행할 수록 DB의 성능이 향상되나요? 그 이유에 대해서도 설명해주세요.**
    > 정규화란 중복을 최소화 함으로써 이상 현상을 줄이기 위한 프로세스입니다. 따라서 일반적으로 정규화를 진행 했을 때, 조인에 따른 오버헤드가 발생하기 때문에 성능은 하락할 수 있습니다. 따라서 정규화 정도에 따른 장단점을 명확히 이해하고 각각의 테이블에 적합한 정규화 레벨을 설정하는 것이 중요합니다.
    

#### 7. 락 (Lock)

- **DB Lock이 무엇인지 설명해주세요.**
    > DB Lock은 데이터베이스 내의 데이터에 접근 권한을 제어하여 동시성 문제를 해결하기 위한 메커니즘입니다. 락을 사용하면 트랜잭션이 특정 데이터에 대해 변경을 수행할 때 다른 트랜잭션이 동일 데이터에 접근하지 못하도록 하여 데이터 무결성을 보장합니다.
    >
- **Optimistic Lock과 Pessimistic Lock에 대해서 설명해주세요.**
    > Optimistic Lock은 데이터 충돌이 드물다고 가정하고 데이터 변경 시 충돌을 검증하는 방식입니다. 주로 버전 정보를 이용하여 충돌 여부를 확인합니다. 반면, Pessimistic Lock은 충돌이 자주 발생할 것이라고 가정하고 데이터 접근 시점에 미리 잠금을 걸어 충돌을 방지하는 방식입니다. Optimistic Lock은 주로 읽기 작업이 많은 경우에 사용되고, Pessimistic Lock은 충돌 가능성이 높은 경우에 적합합니다.
    >
- **공유 락과 배타 락에 대해 설명해주세요.**
    > 공유 락(Shared Lock)은 데이터 읽기 시 걸리는 락으로, 여러 트랜잭션이 동시에 공유 락을 설정할 수 있습니다. 반면, 배타 락(Exclusive Lock)은 데이터 쓰기 시 걸리는 락으로, 다른 트랜잭션이 해당 데이터에 접근하지 못하도록 제한합니다. 공유 락은 데이터 조회 시 사용되며, 배타 락은 데이터 수정 시 사용됩니다.
    >
- **다중 트랜잭션 상황에서의 Deadlock 상황과, 이를 해결하기 위한 방법에 대해 설명해 주세요.**
    > 두개의 트랜잭션이 같은 두개의 리소스에 배타락을 걸어야 한다고 가정하고 각각 하나의 리소스에 Lock을 건 상태일 때, 두 트랜잭션 모두 Lock이 해제되기를 기다려야 합니다. 이런 상황을 다중 트랜잭션에서의 Deadlock 상황이라고 합니다. 이를 해결하기 위해서는 트랜잭션의 진행 방향을 같은 방향으로 처리하는 방법이 있습니다. 또한 트랜잭션 처리 속도를 줄이고 Lock Timeout을 이용하여 잠금 해제 시간을 조절하는 방식도 존재합니다.
    

#### 8. Connection Pool
- **Connection Pool이 무엇인지 설명해주세요.**
    > 일반적으로 클라이언트에서 DB에 어떤 요청을 진행하면 커넥션을 맺고 해당 요청을 수행한 뒤 커넥션을 해제하는 과정을 거칩니다. 이 때, DB 서버와의 연결 비용을 최소화 하기 위해 어플리케이션과 DB사이에 일정 수의 커넥션을 생성해두고 어플리케이션에서는 DB 접근이 필요할 때마다 이미 생성되어 있는 connection을 가져다가 쓰고 반환하는 방식을 Connection Pool이라고 합니다.
    
- **DB와 Client가 Connection을 구성하는 방법을 설명해주세요.**
  > 클라이언트가 데이터베이스에 연결 요청을 보내면 데이터베이스는 연결을 수립하여 클라이언트에 응답합니다. 이 과정에서 연결 설정과 해제가 자주 발생하면 성능에 영향을 줄 수 있으므로 Connection Pool을 사용하여 미리 연결을 생성하고 필요 시 재사용합니다. 이를 통해 클라이언트가 빠르게 연결을 가져올 수 있도록 하여 성능을 높일 수 있습니다.
  
  
#### 9. Traffic Management
- **만약 테이블 내에 데이터가 너무 많아서 성능이 저하되는 경우 어떻게 처리할 수 있을 지 말해주세요.**
    > 테이블의 데이터를 분산하여 성능을 향상시키기 위해 수평 또는 수직 파티셔닝을 사용할 수 있습니다. 또한, 인덱스를 최적화하거나 캐싱을 통해 자주 조회되는 데이터의 성능을 높일 수 있으며, 불필요한 데이터를 아카이빙하여 테이블 크기를 줄이는 방법도 있습니다.
    
- **만약 데이터베이스에 요청이 너무 많아서 성능이 저하되는 경우 어떻게 처리할 수 있을 지 말해주세요.**
    > 데이터베이스 요청이 많은 경우에는 Connection Pool을 늘려 동시 연결 수를 조절하거나, Read Replica를 구성하여 읽기 요청을 분산할 수 있습니다. 또한, 캐시를 사용하여 자주 조회되는 데이터를 캐싱해 DB 부하를 줄이고, 특정 쿼리를 최적화하여 처리 성능을 높일 수도 있습니다.
    >
- **수평 파티셔닝과 샤딩(Sharding)의 차이점이 무엇인가요?**
  > 수평 파티셔닝은 테이블 데이터를 여러 분할된 파티션에 나누어 저장하는 방식으로, 일반적으로 동일 데이터베이스 내에서 이루어집니다. 반면, 샤딩은 데이터베이스를 여러 서버에 분산하여 관리하는 방법으로, 대규모 트래픽 처리 및 확장성을 위해 사용됩니다.
  
- **만약 본인이 DB를 분산해서 관리해야 한다면, 레플리케이션 방식과 샤딩 방식 중 어떤 것을 사용할 것 같나요?**