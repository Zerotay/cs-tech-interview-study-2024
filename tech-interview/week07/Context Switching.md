# Context Switching

- 컨텍스트 스위칭에 대해 설명해주세요.

  > - 하나의 CPU는 한 번에 하나의 스레드만을 실행시킬 수 있습니다. 이 때, 현대 CPU의 경우 빠르게 여러 개의 프로세스를 번갈아 실행하는 방식으로 동시성을 제공합니다. Context Switching이란 운영체제에서 작업하는 프로세스 또는 스레드 간의 전환되는 것을 의미합니다. I/O작업을 위한 인터럽트가 발생하거나 프로세스에 할당된 time slice가 만료된 경우 등의 상황에 Context Switching이 일어납니다. 
  > - Context Switching은 다음과 같은 순서로 일어납니다.
  > - 먼저, 현재 실행중인 프로세스에 대한 상태를 PCB에 저장합니다. 이후 Ready Queue에서 다음 실행할 프로세스를 결정하고 해당 프로세스의 PCB로부터 레지스터 값과 프로그램 카운터 등의 실행 상태를 복원합니다. 이후 메모리 공간이 변경된 경우, 프로세스 메모리 영역을 변경한 후 다음 프로세스를 진행합니다. 

- 프로세스 컨텍스트 스위칭과 스레드 컨텍스트 스위칭의 차이점은 무엇인가요 ?

  > 프로세스의 컨텍스트 스위칭과 스레드의 컨텍스트 스위칭의 가장 큰 차이점은 **프로세스 컨텍스트 스위칭의 경우 가상 메모리 주소 관련 처리를 추가적으로 수행**한다는 점입니다. 가상 메모리 주소를 실제 메모리 주소로 변환해주는 MMU (Memory Management Unit)가 새로운 프로세스의 메모리 주소를 바라볼 수 있도록 해야하고, 실제 메모리 주소의 캐시 역할을 진행하는 TLB도 비워줘야 합니다. 

- **단기, 중기, 장기 스케줄러에 대해 설명해주세요.**
  >  컴퓨터에는 단기, 중기, 장기 스케줄러 있습니다. 장기 스케줄러의 경우 프로세스 실행시에 해당 프로세스를 메모리 위 적재하여 Ready Queue에 넣을지 말지를 결정하는 역할을 수행합니다. 중기 스케줄러의 경우 메모리에 올라와 있는 프로세스 중 Swap out 할 프로세스를 결정합니다. 마지막으로 단기 스케줄러의 경우 Ready Queue에 있는 프로세스들 중 CPU를 할당 할 프로세스를 결정하기 위해 사용됩니다. 

- **현대 OS 에서 사용되는 스케줄러 방식에 대해 설명해주세요.**

  >  현대의 시분할 시스템에서 생성된 프로세스는 모두 Ready Queue에 추가되며 장기 스케줄러는 사용하지 않는 것이 일반적입니다. 

- **OOM(Out Of Memory)가 발생한 경우 Process는 어떠한 상태로 변화하나요 ?**

  >메모리 부족으로 인해 필요한 자원이 사용 불가능해지면 프로세스는 대기상태(Waiting)로 전환될 수 있습니다. 이 때, CPU 자원을 모두 반환하고 다른 필요한 시스템 자원을 기다립니다.
  >
  >또한 메모리 부족으로 인해 Process가 중단되어야 하는 경우 OS는 해당 Process를 일시 중단(Suspend)할 수 있습니다. 이 상태에서는 메모리 내의 해당 프로세스의 모든 페이지가 제거되며 다시 실행하기 전 복원하여야 합니다. 

- **알고 있는 프로세스 스케줄링 알고리즘들을 말해주세요.**

  >  프로세스 스케줄링 알고리즘(단기 스케줄링 알고리즘)은 FIFO, SJF, 우선순위큐, RR 등이 있습니다. 
  >
  > FIFO(First-In-First-Out)의 경우 먼저 Ready Queue에 들어온 프로세스부터 CPU에 할당하는 방법입니다. 이와 같은 경우 CPU 점유 시간이 짧은 프로세스가 이전 프로세스 때문에 오랜 시간 기다려야 하는 경우가 발생할 수 있습니다.
  >
  > SJF(Short-Job-First)의 경우 평균 대기 시간을 줄이기 위해 대기 하고 있는 프로세스 중 CPU 점유 시간이 짧은 프로세스(Short burst process)에 우선적으로 CPU를 할당하는 방식입니다. 해당 알고리즘은 계속해서 CPU 점유 시간이 짧은 프로세스가 들어오면 CPU 점유시간이 긴 프로세스의 경우 영원히 CPU를 할당받지 못하는 Starvation 현상이 발생할 수 있습니다.
  >
  > 우선순위 큐와 같은 경우에는 프로세스마다 우선순위를 부여하고 프로세스의 우선순위에 따라 스케줄링을 수행합니다. 큐에서 가장 높은 우선순위를 가지는 프로세스가 실행되며, 동일한 우선순위를 가지는 프로세스끼리는 FCFS로 처리됩니다. 우선순위 큐는 선점형과 비선점형 두 가지로 구현될 수 있습니다. 해당 알고리즘 또한 낮은 우선순위의 프로세스가 영원히 CPU를 할당 받지 못하는 Starvation 현상이 발생할 수 있습니다. 
  >
  > RR(Round-Robin)은 시분할 방식으로 여러 프로세스 간에 CPU 시간을 공평하게 분할하여 실행하는 방식입니다. 각 프로세스는 동일한 Time Slice 동안 CPU를 할당받게 되고, Time Slice가 지나면 현재 실행 중인 프로세스는 중지된 후 Ready Queue로 돌아가고 다음 프로세스가 실행되는 방식으로 동작합니다. 

- **RR(Round Robin) 알고리즘에서 Time Slice에 따른 Trade-Off를 설명해주세요.**

  > RR에서 Time Slice가 길어지면 각 프로세스들 간의 실행되는 텀이 길어져 응답 시간이 느려지고, 만약 Time Slice가 짧다면 Context Switching이 더 빈번하게 일어나 오버헤드가 발생하게 됩니다. 

- **Multi-level Feedback Queue에 대해 설명해주세요.**

  > Multi-Level Feedback Queue는 여러 개의 우선순위 큐를 사용하여 프로세스를 관리하는 방식입니다. 각 Queue는 다른 우선 순위를 가지며, 서로 다른 스케줄링 알고리즘을 사용할 수 있습니다. 처음 프로세스가 Queue에 도착하면 가장 높은 우선순위 큐에 할당되고 프로세스가 큐에서 실행되는 동안 프로세스의 우선순위가 feedback에 따라 변경될 수 있습니다. 
  >
  > 예를 들어, 일정 시간 동안 device queue에서 I/O 작업을 대기하는 프로세스는 우선순위가 낮은 큐로 이동될 수 있습니다. 
  >
  > 해당 알고리즘의 특징으로는 각 level의 queue마다 개별적인 스케줄링 알고리즘을 적용할 수 있다는 것과 각 level 별로 time slice를 조절할 수 있다는 것입니다. 